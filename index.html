<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>COMPSAC 2018 - Property-Based Testing of Browser Rendering Engines with a Consensus Oracle</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <!-- <link rel="stylesheet" href="lib/css/zenburn.css"> -->

    <!-- Custom overrides -->
    <link rel="stylesheet" href="css/custom.css">

    <link rel="stylesheet" href="lib/css/darcula.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h2>Property-Based Testing of Browser Rendering Engines with a Consensus Oracle</h2>
          <p><font color="#ffea9a">COMPSAC 2018</font></p>
          <ul style="list-style: none">
            <li><font color="green">Joel Martin</font>
              <ul style="list-style: none">
                <li>University of Texas, Arlington
                  <li>ViaSat, Inc
              </ul>
            <li><font color="green">David Levine</font>
              <ul style="list-style: none">
                <li>Univeristy of Texas, Arlington
              </ul>
          </ul>
          <!-- <p><i>Press 's' to show speaker notes</i></p> -->
          <aside class="notes">
            <ul>
              <li>Silence phone
              <li>Full screen the projector screen
              <li>
                Good morning everyone!

                My name is Joel Martin. I'm a Principal Software Engineer at
                ViaSat, Inc and I am also a PhD candidate at the University of
                Texas, Arlington. My co-author on this paper is David Levine from
                the University of Texas, Arlington. <!--The title of this paper is
                'Property-Based Testing of Browser Rendering Engines with
                a Consensus Oracle'--> Let's jump right in.
            </ul>
          </aside>
        </section>
        <section>
          <section>
            <h2>The Problem</h2>
            <ul>
              <li class="fragment" style="list-style: none"><font color="green">The Test Oracle Problem</font></li>
            </ul>
            <aside class="notes">
              <ul>
                <li>
                  The are some systems where determining correct
                  behavior during testing is difficult. To be more
                  precise: there exists a class of systems under test
                  for which the process of determining the correct
                  output based on a given input has a similar order of
                  complexity to the system under test itself. This is
                  the Test Oracle Problem
                  <font color="green"> [show #1]</font>. Our
                  paper proposes an approach to address this problem
                  in the context of web browser render testing.
              </ul>
            </aside>
          </section>
          <section>
            <h3>Browser Rendering</h3>
            <div style="position:relative">
              <pre style="position:absolute" class="fragment" data-fragment-index=1><code class="html" data-noescape>
&lt;html&gt;
  &lt;body style="background: #1289af"&gt;
    &lt;div style="<span class="fragment mark-current-blue" data-fragment-index=2>left: 10%; width: 20%;</span>
                font: <span class="fragment mark-current-blue" data-fragment-index=5><span class="fragment mark-current-blue" data-fragment-index=3>'Fira Sans'</span> 25px/1</span>
                      <span class="fragment mark-current-blue" data-fragment-index=4>rgba(100,100,100,0.5)</span>"&gt;
      <span class="fragment mark-current-blue" data-fragment-index=5>Pythia, Apollo, Dione.</span>
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
              </code></pre>
            </div>
            <aside class="notes">
              <ul>
                <li>
                  Let's consider a browser rendering test case.
                  <font color="green">[show #1]</font> Even
                  though this web page is fairly simple compared to
                  real-world web pages, it is still non-trivial to
                  verify that a browser has rendered this page
                  correctly. There are a number of reasons for this:
                  <ul>
                    <li><font color="green">[show #2]</font>
                      The CSS element sizing and positioning
                      standard is large and nuanced (and one of the
                      basic things we would like to test)
                    <li><font color="green">[show #3]</font>
                      environment factors: browser window geometry,
                      available OS fonts 
                    <li><font color="green">[show #4]</font>
                      color model and alpha blending 
                    <li><font color="green">[show #5]</font>
                      font rendering model (especially spacing
                      issues like kerning which may cause other page
                      elements to shift significantly)
                  </ul>
                  Current solutions to browser render testing often
                  involve manual user intervention at some stage of
                  the process and use a highly constrained test
                  environment. Our paper proposes an approach that is
                  both comprehensive and fully automated.
              </ul>
            </aside>
          </section>
          <section>
            <h2>A Solution</h2>
            <ul>
              <li class="fragment">Property-Based Testing (PBT)</li>
              <li class="fragment">Grammar-Based Input Generators</li>
              <li class="fragment">Consensus-Based Test Oracle</li>
            </ul>
            <aside class="notes">
              There are three main components to our approach.
              <ul>
                <li><font color="green">[show #1]</font>
                  Property-based testing,
                <li><font color="green">[show #2]</font>
                  grammar-based input generators,
                <li><font color="green">[show #3]</font>
                  and a consensus-based test oracle.
              </ul>
              Let's consider each one in turn.
            </aside>
          </section>
        </section>
        <section>
          <section>
            <h2>Property-Based Testing (PBT)</h2>
            <ul>
              <li>QuickCheck (Claessen &amp; Hughes, 2000)
              <li>Input properties: generators
              <li>Output properties: success/failure (e.g. test Oracle)
              <li>Output property violations indicate test failure
              <li>Grow "size" until output properties violated
            </ul>
            <aside class="notes">
              <ul>
                <li>Property-based testing is a testing methodology
                  that was popularized by the QuickCheck system
                  proposed by Koen Claessen and John Hughes in 2000.
                <li>In property-based testing the tester defines
                  properties or assertions about the input and output
                  values of the system under test.
                <li>Input properties define the range of valid inputs
                  to the SUT. Output properties are used by the test
                  system to validate outputs for a given set of
                  inputs. When output properties are violated the
                  corresponding inputs are considered a failing test
                  case.
                <li>A typical PBT system defines input properties in
                  terms of generator functions. Generator functions
                  can be combined to create compound generators which
                  can also be recursive.
                <li>Each input property generator function takes
                  a size value which has a generator specific
                  meaning. A single run of property-based testing
                  involves calling the input properties with larger
                  and larger size values to stochastically generate
                  large and large test cases until the output
                  properties are violated.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>PBT Test Shrinking</h3>
            <ul class="fragment">
              <li>Tree of generator nodes
              <li>Pick node, try small size value
              <li>Continue until "smallest" discovered
              <li>Critical for compound/recursive generators
            </ul>
            <aside class="notes">
              <ul>
                <li>The highly recursive nature of the HTML
                  grammar means that generated test cases can become
                  before large.
                <li>There is a positive aspect to this in that large
                  cases can each achieve non-trivial code coverage of
                  the system under test.
                <li>The major downside to this is that large test
                  cases are not helpful to the tester in doing root
                  cause analysis.
                <li>Test shrinking can significantly reduce the size
                  of the test case while still preserving the failure
                  in the system under test. How does it work?
                <li><font color="green">[show #1]</font>
                  We can think of each test case is a tree of
                  generator nodes. Shrinking process picks a node in
                  the tree and tries a smaller size value. If
                  resulting test case is smaller then continue
                  otherwise backtrack. Continue until a minima is
                  reached.
                <li>Extremely important for complex compound
                  generators (e.g. recursive). Hard to overstate the
                  importance of test shrinking.
              </ul>
            </aside>
        </section>
          <section data-transition="none">
            <h3>Simple PBT Example</h3>
            <div style="position:absolute">
              <ul>
                <li>Input property: P is a sequence of integers</li>
                <li>Output property: sum of integers in P <font style="visibility: hidden" color="green">(almost)</font></li>
              </ul>
              <pre class="fragment" data-fragment-index=1><code class="clojure" data-noescape>> <span class="fragment mark-current-blue" data-fragment-index=2>(def SUT
    (fn [x] (apply + x)))</span>

> (<span class="fragment mark-current-blue" data-fragment-index=6>tc/quick-check 10</span>
    (<span class="fragment mark-current-blue" data-fragment-index=5>props/for-all</span>
      <span class="fragment mark-current-blue" data-fragment-index=3>[P (gen/vector gen/int)]</span>
      <span class="fragment mark-current-blue" data-fragment-index=4>(= (SUT P) (apply + P))</span>))
<span class="fragment mark-current-blue" data-fragment-index=7>{:result true,
 :num-tests 10}</span>



              </code></pre>
            </div>
            <aside class="notes">
              <ul>
                <li>Let's consider a simple example.
                <li>We define the input property as a sequence of
                  integers.
                <li>The output property states that the output of the
                  SUT is the sum of the values in input sequence.
                <li><font color="green">[show #1]</font>
                  Here is code showing what this would look like
                  implemented with Clojure's test.check library.
                  Namespace imports have been elided.
                <li><font color="green">[show #2]</font>
                  First we define the SUT to be the application of sum
                  to a sequence.
                <li><font color="green">[show #3]</font>
                  The input property P is defined as a compound
                  generator which generates a vector of integers.
                <li><font color="green">[show #4]</font>
                  The output property states that the execution of
                  the SUT on P should have the exact same result
                  as apply sum to the values in P.
                <li><font color="green">[show #5]</font>
                  We define our properties using the props-all
                  function.
                <li><font color="green">[show #6]</font>
                  and we call the quick-check function to run 10
                  test iterations.
                <li><font color="green">[show #7]</font>
                <li>The final two lines are the result of the test
                  showing that all 10 iterations were run with no
                  property violations.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Simple PBT Example</h3>
            <div style="position:absolute">
              <ul>
                <li>Input property: P is a sequence of integers</li>
                <li>Output property: sum of integers in P <font style="visibility: hidden" color="green">(almost)</font></li>
              </ul>
              <pre><code class="clojure" data-noescape>> (def SUT
    (fn [x] (apply + x)))

> (tc/quick-check 100
    (props/for-all
      [P (gen/vector gen/int)]
      (= (SUT P) (apply + P))))
{:result true,
 :num-tests 100}



              </code></pre>
            </div>
            <aside class="notes">
              <ul>
                <li>We can increase the number of iterations to 100
                  and see that the result is unchanged. Which is not
                  surprising since our test Oracle output property and
                  the SUT are currently defined identically.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Simple PBT Example</h3>
            <div style="position:absolute">
              <ul>
                <li>Input property: P is a sequence of integers</li>
                <li>Output property: sum of integers in P <font color="green">(almost)</font></li>
              </ul>
              <pre><code class="clojure" data-noescape>> (def SUT
    (fn [x] (if (<= 13 (count x) 17) 0 (apply + x))))

> (tc/quick-check 10
    (props/for-all
      [P (gen/vector gen/int)]
      (= (SUT P) (apply + P))))
{:result true,
 :num-tests 10}



              </code></pre>
            </div>
            <aside class="notes">
              <ul>
                <li>Now let's introduce a bug in our SUT such that
                  any sequence containing 13 to 17 integers will
                  result in the value 0 being returned instead of the
                  sum.
                <li>Our properties remain unchanged.
                <li>We can see that running 10 iterations still passed
                  because the sizes being generated P are still small
                  and no sequence long enough to trigger the bug is
                  generated.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Simple PBT Example</h3>
            <div style="position:absolute">
              <ul>
                <li>Input property: P is a sequence of integers</li>
                <li>Output property: sum of integers in P <font color="green">(almost)</font></li>
              </ul>
              <pre><code class="clojure" data-noescape>> (def SUT
    (fn [x] (if (<= 13 (count x) 17) 0 (apply + x))))

> (tc/quick-check 100
    (props/for-all
      [P (gen/vector gen/int)]
      (= (SUT P) (apply + P))))
{:result false,
 :num-tests <span class="fragment mark-current-blue" data-fragment-index=1>31</span>,
 :fail [<span class="fragment mark-current-blue" data-fragment-index=2>[1 19 12 18 -7 30 -8 15
         13 -15 8 -3 1 -21 10 19]</span>],
 :shrunk {:total-nodes-visited <span class="fragment mark-current-blue" data-fragment-index=3>262</span>,
          :smallest [<span class="fragment mark-current-blue" data-fragment-index=4>[0 0 0 0 0 0 0 0 0 0 0 0 0]</span>]}} </code></pre>
            </div>
            <aside class="notes">
              <ul>
                <li>However, running with a maximum of 100 iterations
                  triggers a test case failure on the
                  <font color="green">[show #1]</font> 31st iteration.
                <li>The initial input property which triggered the
                  failure contained <font color="green">[show #2]</font> 16 integers.
                <li>After the failure was discovered, the quick-check
                  function ran an addition
                  <font color="green">[show #3]</font> 262 test shrink iterations
                  and found that a sequence of
                  <font color="green">[show #4]</font> 13 zeros that triggers
                  the failure. This is the smallest test case that was
                  found that still triggered the failure.
              </ul>
            </aside>
          </section>
        </section>
        <section data-transition="none">
          <section>
            <h2>Input Generators</h2>
            <ul>
              <li>Test Case Composition (web pages):
                <ul>
                  <li>HTML (content)
                  <li>CSS (presentation)
                </ul>
              <li class="fragment">Goals:
                <ul>
                  <li>Automated
                  <li>Controllable
                  <!--<li>Comprehensive-->
                </ul>
            </ul>
            <aside class="notes">
              <ul>
                <li>Now let's talk about the the input properties for
                  browser render testing. In this case we want to
                  generate web pages which mean generating HTML and
                  CSS. These basically represent the content and
                  presentation respectively. The third component of
                  web page is the behavior defined in JavaScript but
                  that is not in scope for our paper.
                <li><font color="green">[show #1]</font>
                  The are several goal we want for our generators:
                  <ul>
                    <li><b>Automated</b>: We want automated creation
                      of the generators themselves, and we also want
                      the generators to output full web pages that don't
                      require human final assembly or tweaking.
                    <li><b>Controllable</b>: Because the domain of valid web
                      pages is essentially unbounded, we want the
                      tester to have the ability to choose more narrow
                      domains to focus on.
                    <!--
                    <li><b>Comprehensive</b>: we want web pages that cover
                      the whole domain valid web pages. So generators
                      themselves are generated from raw data from
                      upstream HTML and CSS standards.
                    -->
                  </ul>
              </ul> 
            </aside>
          </section>
          <section>
            <h3>Grammar-Based Generators</h3>
            <ul>
              <li class="fragment">W3C Standards &rarr; Data
              <li class="fragment">Data &rarr; EBNF
              <li class="fragment">EBNF &rarr; Generators
              <li class="fragment">Generators &rarr; HTML+CSS
            </ul>
            <aside class="notes">
              <ul>
                <li><font color="green">[show #1]</font>
                  Our basic approach is to use first download and
                  normalize HTML and CSS specification data.
                <li><font color="green">[show #1]</font>
                  Then we load that data and use it to generate
                  EBNF grammars that can parse web pages containing
                  HTML and CSS.
                <li><font color="green">[show #1]</font>
                  Then we parse the EBNF grammar files and output
                  generator functions for each of the rules in the
                  grammar.
                <li><font color="green">[show #1]</font>
                  Finally, the PBT test harness is able to use the
                  generators for our input properties to generate HTML
                  and CSS test cases.
              </ul> 
            </aside>
          </section>
          <section>
            <h3>HTML 5</h3>
            <ul>
              <li>W3C Standard
              <li>130 Elements (tags)
              <li>110 Attributes
            </ul>
            <aside class="notes">
              <ul>
                <li>Let's talk briefly about HTML. HTML is a World
                  Wide Web Consortium standard. HTML 5 is the current
                  major version of the standard.
                <li>HTML is composed of two major parts: elements and
                  attributes.
                <li>The standard defines approximate 130 HTML elements
                  and 110 attributes.
              </ul> 
            </aside>
          </section>
          <section>
            <h3>HTML Example</h3>
            <pre><code class="html" data-noescape>&lt;<span class="fragment mark-current-blue" data-fragment-index=2>html</span>&gt;
  &lt;<span class="fragment mark-current-blue" data-fragment-index=2>body</span>&gt;
    page document body
    &lt;<span class="fragment mark-current-blue" data-fragment-index=2>div</span>&gt; div content &lt;/<span class="fragment mark-current-blue" data-fragment-index=2>div</span>&gt;
    &lt;<span class="fragment mark-current-blue" data-fragment-index=2>span</span> <span class="fragment mark-current-blue" data-fragment-index=3>class="myclass1"</span>&gt; span content &lt;/<span class="fragment mark-current-blue" data-fragment-index=2>span</span>&gt;
    &lt;<span class="fragment mark-current-blue" data-fragment-index=2>div</span> <span class="fragment mark-current-blue" data-fragment-index=3>id="mydiv1"</span>&gt; div content &lt;/<span class="fragment mark-current-blue" data-fragment-index=2>div</span>&gt;
    &lt;<span class="fragment mark-current-blue" data-fragment-index=2>b</span> <span class="fragment mark-current-blue" data-fragment-index=3>style="text-color: red"</span>&gt; bold red text &lt;/<span class="fragment mark-current-blue" data-fragment-index=2>b</span>&gt;
    &lt;<span class="fragment mark-current-blue" data-fragment-index=2>div</span>&gt;
      &lt;<span class="fragment mark-current-blue" data-fragment-index=2>b</span>&gt; bold text within a div &lt;/<span class="fragment mark-current-blue" data-fragment-index=2>b</span>&gt;
      &lt;<span class="fragment mark-current-blue" data-fragment-index=2>span</span>&gt; span content within a div &lt;/<span class="fragment mark-current-blue" data-fragment-index=2>span</span>&gt;
    &lt;/<span class="fragment mark-current-blue" data-fragment-index=2>div</span>&gt;
    &lt;<span class="fragment mark-current-blue" data-fragment-index=2>a</span> <span class="fragment mark-current-blue" data-fragment-index=3>href="http://w3c.org"</span>&gt; text of link to W3C &lt;/<span class="fragment mark-current-blue" data-fragment-index=2>a</span>&gt;
  &lt;/<span class="fragment mark-current-blue" data-fragment-index=2>body</span>&gt;
&lt;/<span class="fragment mark-current-blue" data-fragment-index=2>html</span>&gt;</code></pre>
            <aside class="notes">
              <ul>
                <li>Here is an example web page HTML
                <li>There are two major components of HTML.
                <li><font color="green">[show #1]</font>
                    First: elements which are delineated by tags.
                <li>Note that the grammar for HTML elements is
                  recursive and permits elements to be contained
                  within other elements.
                <li><font color="green">[show #1]</font>
                    Second: HTML attributes.
                <li>Some attributes like class and id are global while
                  other like href are specific to certain types of
                  elements.
              </ul> 
            </aside>
          </section>
          <section>
            <h3>CSS 3</h3>
            <ul>
              <li>W3C Standard
              <li>50 sub-specifications (modules)
              <li>360 CSS properties
            </ul>
            <aside class="notes">
              <ul>
                <li>CSS is also a World Web Consortium standard.
                <li>CSS 3 is the major version of the standard.
                <li>The CSS standard is a fair bit more complicated
                  than the HTML one in terms of its grammar.
                <li>There are actually 50 different sub-specifications
                  referred to as CSS3 modules which are in various
                  stages of standardization.
                <li>There are more than 360 CSS property names across
                  all the CSS3 modules.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>CSS 3 Example</h3>
            <ul style="list-style: none">
              <li>Stylesheet:
            </ul>

            <pre><code class="css"  data-noescape><span class="fragment mark-current-blue" data-fragment-index=1>.classname #idname tagname</span> {
  <span class="fragment mark-current-blue" data-fragment-index=2><span class="fragment mark-current-blue" data-fragment-index=3>background</span>: <span class="fragment mark-current-blue" data-fragment-index=4>rgba(0, 0, 0, 0.5);</span></span>
  <span class="fragment mark-current-blue" data-fragment-index=2><span class="fragment mark-current-blue" data-fragment-index=3>border</span>: <span class="fragment mark-current-blue" data-fragment-index=4>1px solid #fff;</span></span>
  <span class="fragment mark-current-blue" data-fragment-index=2><span class="fragment mark-current-blue" data-fragment-index=3>transform</span>: <span class="fragment mark-current-blue" data-fragment-index=4>translate3d(0px, 0px, -45px) rotateX(90deg);</span></span>
}
            </code></pre>
            <aside class="notes">
              <ul>
                <li>Here is an example of a CSS stylesheet.
                <li>There are four main components
                <li><font color="green">[show #1]</font>
                  Selectors, which identify which HTML elements the
                  following block will apply to.
                <li><font color="green">[show #2]</font>
                  A block of declarations.
                <li>Each declaration consists of ...
                <li><font color="green">[show #3]</font>
                  Property names and ...
                <li><font color="green">[show #4]</font>
                  Value data
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>CSS 3 Example</h3>
            <ul style="list-style: none">
              <li>Inline:
            </ul>
            <pre><code class="html"  data-noescape>&lt;div style="background: rgba(0, 0, 0, 0.5);
            border: 1px solid #fff;
            transform: translate3d(0px, 0px, -45px)
                       rotateX(90deg);"&gt;
  div content
&lt;/div&gt;
            </code></pre>
            <aside class="notes">
              <ul>
                <li>These are the same definitions from the previous
                  example but embedded inline into the HTML.
                <li>The selectors are omitted because these
                  declarations only apply to the HTML elements that
                  they embedded within.
              </ul>
            </aside>
          </section>
          <section>
            <h3>CSS Value Definition Syntax (VDS)</h3>
            <ul class="fragment" style="list-style: none">
              <li>VDS
            <pre><code class="css overflow"  data-noescape><'text-emphasis-position'> =
  [ over | under ] && [ right | left ]</code></pre>
              <li class="fragment">EBNF
            <pre><code class="bash overflow"  data-noescape>prop-text-emphasis-position =
  ( ( 'over' ' ' | 'under' ' ') ' '
    ( 'right' ' ' | 'left' ' ') ' ' ) ;</code></pre>
            <aside class="notes">
              <ul>
                <li>Bulk of the CSS3 standard is dedicated to defining
                  CSS values.
                <li>CSS values are defined using a bespoke grammar
                  called Value Definition Syntax (or VDS).
                <li>The grammar is similar to EBNF but with additional
                  combinators that are optimized to deal with the
                  ordering and repetition flexibility that CSS values
                  permits.
                <li><font color="green">[show #1]</font>
                  Here is an example of the VDS definition of the
                  values for the <b>text-emphasis-position</b>
                  property name.
                <li>This definition states that the value should be
                  either the word "over" or "under" and either the
                  word "right" or "left".
                <li><font color="green">[show #1]</font>
                  This is the equivalent EBNF translation of the VDS
                  grammar.
              </ul>
            </aside>
          </section>
          <section>
            <h3>CSS Value Definition Syntax (VDS)</h3>
            <ul style="list-style: none">
              <li>EBNF
            <pre><code class="bash overflow"  data-noescape>prop-text-emphasis-position =
  ( ( 'over' ' ' | 'under' ' ') ' '
    ( 'right' ' ' | 'left' ' ') ' ' ) ;</code></pre>
              <li>Generators:
            <pre><code class="clojure overflow"  data-noescape>(gen/tuple
  (gen/frequency [
    [100 (gen/tuple (gen/return "over") (gen/return " "))]
    [100 (gen/tuple (gen/return "under") (gen/return " "))]])
  (gen/return " ")
  (gen/frequency [
    [100 (gen/tuple (gen/return "right") (gen/return " "))]
    [100 (gen/tuple (gen/return "left") (gen/return " "))]])
  (gen/return " "))
            </code></pre>
            </ul>
            <aside class="notes">
              <ul>
                <li>The EBNF is then translated into Clojure
                  test.check generator code.
                <li>The frequency generator selects between multiple
                  other generators based on weights. In this case the
                  even weights result in 50% chance of choosing the
                  over/under and right/left pairs.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Controlling the Grammar</h3>
            <ul>
              <li>Tunable weights at grammar branch points
              <li class="fragment">Enables:
                <ul>
                  <li>Single component testing
                  <li>Avoid known failures
                  <li>Pairwise or combinatorial testing
                  <li>Typical and atypical test cases
                </ul>
            </ul>
            <aside class="notes">
              <ul>
                <li>One of our goals of our overall approach is that
                  the system is controllable.
                <li>We accomplish this by having tunable weights
                  associated with each branch point in the grammar.
                <li><font color="green">[show #1]</font>
                  Grammar controlability enables a number of
                  interesting scenarios such as:
                  <ul>
                    <li><b>Single component testing</b>. For example
                      there may be a new HTML element that we want to
                      focus our testing on.
                    <li><b>Avoid known failures</b>. For example, we
                      may have found a bug hyperlink rendering that
                      occurs frequently. We can continue testing
                      without requiring a fix to the SUT by disabling
                      the part of the grammar that generates
                      hyperlinks.
                    <li><b>Pairwise or combinatorial testing</b>. Many
                      bugs are triggered by the interaction a small
                      number of components that make up the SUT. So
                      pairwise and combinatorial testing can be an
                      efficient way to locate bugs in the SUT.
                    <li><b>Typical and atypical test cases</b>.
                      Sometimes we are interested in testing our SUT
                      on typical data. For example we may want to gain
                      confidence that our browser will render the top
                      100 web sites correctly. Other times we may want
                      to focus on uncommon elements. Perhaps we just
                      introduced some new elements to the SUT that are
                      not widely used yet.
                  </ul>
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Revisiting the Grammar</h3>
            <ul style="list-style: none">
              <li><font color="yellow">text-emphasis-position</font> generator:
            <pre><code class="clojure overflow"  data-noescape>(gen/tuple
  (gen/frequency [
    [100                                                          &nbsp;
      (gen/tuple (gen/return "over") (gen/return " "))]
    [100
      (gen/tuple (gen/return "under") (gen/return " "))]])
  (gen/return " ")
  (gen/frequency [
    [100
      (gen/tuple (gen/return "right" (gen/return " ")))]
    [100
      (gen/tuple (gen/return "left") (gen/return " "))]])
  (gen/return " "))
            </code></pre>
            </ul>
            <aside class="notes">
              <ul>
                <li>Here is the grammar I showed earlier.
                <li>This is actually omitting the extra parts that
                  allow the grammar to be controlled or tuned.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Revisiting the Grammar</h3>
            <ul style="list-style: none">
              <li><font color="yellow">text-emphasis-position</font> generator:
            <pre><code class="clojure overflow"  data-noescape>(gen/tuple
  (gen/frequency [
    [(get weights [:prop-text-emphasis-position :cat 1 :alt 0] 100)
      (gen/tuple (gen/return "over") (gen/return " "))]
    [(get weights [:prop-text-emphasis-position :cat 1 :alt 1] 100)
      (gen/tuple (gen/return "under") (gen/return " "))]])
  (gen/return " ")
  (gen/frequency [
    [(get weights [:prop-text-emphasis-position :cat 3 :alt 0] 100)
      (gen/tuple (gen/return "right") (gen/return " "))]
    [(get weights [:prop-text-emphasis-position :cat 3 :alt 1] 100)
      (gen/tuple (gen/return "left") (gen/return " "))]])
  (gen/return " "))
            </code></pre>
            </ul>
            <aside class="notes">
              <ul>
                <li>Here is what the full emitted grammar looks like
                  with the weight lookups included.
                <li>The weights variable in the example is a lookup
                  table built from the default weights overlayed with
                  value loaded from a tester's weight file.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Weights File</h3>
            <ul style="list-style: none">
              <li>weights.edn:
            <pre><code class="clojure overflow"  data-noescape>{
...
 [:prop-text-emphasis-position :cat 1 :alt 0] 100,
 [:prop-text-emphasis-position :cat 1 :alt 1]  50,
 [:prop-text-emphasis-position :cat 3 :alt 0] 100,
 [:prop-text-emphasis-position :cat 3 :alt 1]  50,
...
}</code></pre>
            <aside class="notes">
              <ul>
                <li>Corresponding data from the weight file.
                <li>This example makes the "over" and "right" words
                  twice as common as under and left.
              </ul>
            </aside>
          </section>
        </section>
        <section data-transition="none">
          <section>
            <h2>Test Oracle</h2>
            <ul>
              <li class="fragment">Goals
                <ul>
                  <li>Automated
                  <li>Controllable
                </ul>
            </ul>
            <aside class="notes">
              <ul>
                <li>We have a way to generate web page test cases
                  that are <b>automated</b> and <b>controllable</b>,
                  but how do determine whether our browser correctly
                  renders these test cases.
                <li>It turns out that our goals for determining
                  correctness are the same as for generating the inputs
                  <li>Goals: <font color="green">[show #1]</font>
                  <ul>
                    <li><b>Automated</b>: a human shouldn't have to
                      determine whether a browser has rendered a web
                      page correctly. Which has means we also need to
                      minimize false positives and false negatives.
                    <li><b>Controllable</b>: To explain why this is
                      important I'll have to descirbe how the test
                      Oracle works.
              </ul> 
            </aside>
          </section>
          <section>
            <h2>Consensus Oracle</h2>
            <ul>
              <li class="fragment">Multiple implementations
              <li class="fragment">Chrome, Firefox, Safari, Edge,
                Opera, Vivaldi, Brave, UC Browser, Internet Explorer,
                Chromium, Servo, Pale Moon, Dolphin, Tor Browser,
                Maxthon, Baidu Browser, etc, etc
            </ul>
            <aside class="notes">
              <ul>
                <li><font color="green">[show #1]</font> The
                  key insight here is that a number of cases in the
                  real-world where SUTs will have multiple
                  implementations.
                <li>This is particularly true in the web browser space
                  where there is a surplus of implementations.<font
                    color="green">[show #1]</font>
              </ul> 
            </aside>
          </section>
          <section>
            <h3>Consensus Example</h3>
            <pre><code class="html"  data-noescape>&lt;html&gt;
  &lt;body style="background: #1289af; font: 25px/1 Ahem"&gt;
    &lt;marquee bgcolor="navy"&gt;
      &lt;q <font color="yellow">...ELIDED...</font> &gt; pX &lt;/q&gt;
    &lt;/marquee&gt;
    p
    &lt;mark <font color="yellow">...ELIDED...</font>&gt; &lt;/mark&gt;
    &lt;strong style="offset-anchor: right;
                   box-align: stretch;
                   padding-right: -1.75vw" <font color="yellow">...ELIDED...</font>&gt;
      &lt;mark <font color="yellow">...ELIDED...</font>&gt; Xp XX &lt;/mark&gt;
      &amp;#x00c9;
    &lt;/strong&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
            <aside class="notes">
              <ul>
                <li>Here is a example web page that was generated
                  using HTML and CSS generators.
              </ul>
            </aside>
          </section>
          <section>
            <h3>Consensus Example</h3>
            <table class="browser-table">
              <tr>
                <td style="padding: 0px; text-align: center; vertical-align: top">
                  <div style="visibility: hidden">FFFFFFF</div>
                  <span>Firefox&nbsp;&nbsp;</span>
                  <img src="imgs/results1_7_firefox.png"
                       style="margin: 5px"></img>
                </td>
                <td style="padding: 0px; text-align: center; vertical-align: top">
                  <div style="visibility: hidden">FFFFFFF</div>
                  <span>Chrome</span>
                  <img src="imgs/results1_7_chrome.png"
                       style="margin: 5px"></img>
                </td>
                <td style="padding: 0px; text-align: center; vertical-align: top">
                  <div style="visibility: hidden">FFFFFFF</div>
                  <span>Servo&nbsp;&nbsp;&nbsp;&nbsp;</span>
                  <img src="imgs/results1_7_servo.png"
                       style="margin: 5px"></img>
                </td>
              </tr>
            </table>
            <aside class="notes">
              <ul>
                <li>And here are the results of rendering that page in
                  three popular browsers.
                <li>It is pretty clear just from visual inspection
                  that Servo has significantly different rendering
                  from the other two however, it's not as obvious
                  whether Firefox and Chrome are different.
              </ul>
            </aside>
          </section>
          <section>
            <table class="browser-table">
              <tr>
                <td style="padding: 0px; text-align: center; vertical-align: top">
                  <span>Firefox</span>
                  <img src="imgs/results1_7_firefox.png"
                       style="margin: 5px"></img>
                </td>
                <td style="padding: 0px; text-align: center; vertical-align: top"
                    class="fragment" data-fragment-index=1>
                  <img src="imgs/results1_7_diff_firefox_servo.png"
                       style="margin: 5px"></img>
                  <div style="visibility: hidden">FFFFFFF</div>
                </td>
                <td style="padding: 0px; text-align: center; vertical-align: top">
                  <span>Servo</span>
                  <img src="imgs/results1_7_servo.png"
                       style="margin: 5px"></img>
                </td>
              </tr>
              <tr>
                <td style="padding: 0px; text-align: center; vertical-align: top"
                    class="fragment" data-fragment-index=1>
                  <img src="imgs/results1_7_diff_firefox_chrome.png"
                       style="margin: 5px"></img>
                  <div style="visibility: hidden">FFFFFFF</div>
                </td>
                <td style="padding: 0px; text-align: center; vertical-align: top">
                  <span>Chrome</span>
                  <img src="imgs/results1_7_chrome.png"
                       style="margin: 5px"></img>
                </td>
                <td style="padding: 0px; text-align: center; vertical-align: top"
                    class="fragment" data-fragment-index=1>
                  <img src="imgs/results1_7_diff_chrome_servo.png"
                       style="margin: 5px"></img>
                  <div style="visibility: hidden">FFFFFFF</div>
                </td>
              </tr>
            </table>
            <aside class="notes">
              <ul>
                <li>Let's re-arrange them
                <li>And now let's show the result of subtracting the
                  color channel values for each pair of browsers.
                  <font color="green">[show #1]</font>
                  Black areas in the difference images mean that color
                  at that pixel in both images was identical.
                <li>Now it's easy to see the difference between Servo
                  and the other two browsers.
                <li>We can also see that Firefox and Chrome are very
                  similar although there are in fact some subtle
                  spacing differences between the HTML elements.
                <li>This raises the question of how do we determine if
                  there is in fact consensus or not?
              </ul>
            </aside>
          </section>
          <section>
            <h3>Consensus?</h3>
            <ul style="list-style: none">
              <li class="fragment">Squared Sum of Differences (SSD) with a threshold.
            </ul>
            <aside class="notes">
              <ul>
                <li>There are numerous methods of comparing two images
                  described in the literature. There is even some
                  consideration of using machine learning approaches
                  for comparing two browser renderings to determine if
                  they are similar enough to be indistinguishable to
                  the human eye.
                <li>The fact is that the comparison method is
                  something that testers in practice will want to have
                  control over. This is an aspect of controllability
                  of the consensus algorith mentioned above.
                <li>We found that a simple Squared Sum of Differences
                  compared to configurable threshold value was
                  sufficient to validate our overall approach.
                  <font color="green">[show #1]</font>
              </ul>
            </aside>
          </section>
          <section>
            <h3>Consensus Yet?</h3>
            <ul style="list-style: none">
              <li class="fragment">One is at fault
              <li class="fragment">All members at fault
              <li class="fragment">No clear fault
            </ul>
            <aside class="notes">
              <ul>
                <li>We now have an answer for whether each pair of
                  browsers are different from each other. With three
                  browsers, there are three pairs of difference
                  values. What if they disagree?
                <li><font color="green">[show #2]</font>
                  It's fairly easy to tell when one browser is at
                  fault because it will be different from all other
                  browsers and the other browsers will have
                  self-similar renders.
                <li><font color="green">[show #2]</font>
                  There is also a case where all browsers may be
                  different from every other browser. This is also
                  a failure case but it may indicate that there is an
                  element on the page that is not well standardized.
                <li><font color="green">[show #2]</font>
                  And there is also a case where there is no clear
                  browser at fault. Consider an example where A and
                  B are below threshold, and B and C are also below
                  the threshold, but A and C are above the threshold
                  and classified as different. In other words, browser
                  B split the difference between the other two.
                <li>This is another area where the tester will want
                  controllability and will likely select different
                  consensus algorithms depending on the goal.
              </ul>
            </aside>
            <!-- TODO: consensus/rendering challenges: borders, Ahem, etc -->
          </section>
          <section>
            <h3>Beyond Browsers</h3>
            <ul>
              <li class="fragment">Implementation of standards
              <li class="fragment">Regression/fix testing
              <li class="fragment">Feature support matrix
            </ul>
            <aside class="notes">
              <ul>
                <li>There are other instances beyond browsers where
                  there are this approach would work. PDF rendering.
                  POSIX utility implementations.
                  <font color="green">[show #2]</font> Basically any
                  area where there is a software will often have
                  multiple implementations.
                <li><font color="green">[show #2]</font>
                  However, not just for cases where there are multiple
                  implementation from different vendors/creators. This
                  approach could also be used for testing of multiple
                  versions of the same SUT.  With a bit of integration
                  with source control and automated testing systems
                  this could be used to identify regressions and
                  if/when they are fixed.
                <li><font color="green">[show #2]</font>
                  It could be used to create a feature matrix
                  showing when a product began supporting a feature by
                  comparing the most recent version against older
                  versions of the product.
              </ul>
            </aside>
          </section>
        </section>
        <section>
          <section>
            <h2>Results</h2>
            <table>
              <tr class="fragment" data-fragment-index=1>
                <th width=35%>&nbsp;</th>
                <th>Median</th>
                <th>Maximum</th>
              <tr class="fragment" data-fragment-index=1>
                <td>First fail</td>
                <td>8 iterations</td>
                <td>15 iterations</td>
              <tr class="fragment" data-fragment-index=2>
                <td>Fail size</td>
                <td>3,025 bytes</td>
                <td>109,983 bytes</td>
              <tr class="fragment" data-fragment-index=3>
                <td>Shrunk</td>
                <td>154 bytes</td>
                <td>245 bytes</td>
            </table>
            <aside class="notes">
              <ul>
                <li>We created an implementation of the approach
                  described and ran the system with a consensus pool
                  that included the Firefox, Chrome and Servo
                  browsers.
                <li>Across 130 test runs, every run identified
                  a failure case before hitting the maximum number of
                  iterations we had specified.
                <li><font color="green">[show #1]</font> In
                  fact, the maximum number of steps until a failing
                  case was found was 15. The median number of
                  iterations to find a failure case was 8.
                <li>We were actually surprised by how quickly the
                  system was able to generate test cases that
                  triggered browser differences. But the reason is
                  something I mentioned earlier: due to the nature of
                  the generators, the size of each test case increases
                  rapidly and large numbers of features are tested per
                  test case.
                <li><font color="green">[show #2]</font> The
                  median size of the first failing test case was
                  3 kilobytes and the maximum was 110 kilobytes.
                <li><font color="green">[show #2]</font> The
                  median size of the test case after shrinking was
                  154 bytes and the maximum was 245 bytes. The median
                  number of steps needed to shrink a test case was
                  113 iterations.
              </ul> 
            </aside>
          </section>
        </section>
        <section>
          <h3>Questions?</h3>
        </section>
        <section>
          <h3>Contact</h3>
          <ul style="list-style: none">
            <li><a href="//twitter.com/bus_kanaka">@bus_kanaka</a>
            <li><a href="//kanaka.github.io/compsac2018">kanaka.github.io/compsac2018</a>
            <li><a href="//github.com/kanaka">github.com/kanaka</a>
            <li>joeldmartin@mavs.uta.edu
            <li>levine@cse.uta.edu
          </ul>
          <aside class="notes">
            <ul>
              <li>
                <li><font color="green">[show #1]</font>
                  <ul>
                    <li>
                  </ul>
            </ul> 
          </aside>
        </section>
        <section>
          <section>
            <h2>Extra Material</h2>
          </section>
          <section>
            <img src="imgs/results1.png" width=80%></img>
            <aside class="notes">
            </aside>
          </section>
          <section>
            <img src="imgs/results1_expanded.png" width=80%></img>
          </section>
          <section>
            <img src="imgs/test_arch.svg" width=35%></img>
          </section>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>

<!-- vim: ts=2:sw=2:set expandtab -->
