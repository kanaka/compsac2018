<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>COMPSAC 2018 - Property-Based Testing of Browser Rendering Engines with a Consensus Oracle</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <!-- <link rel="stylesheet" href="lib/css/zenburn.css"> -->

    <!-- Custom overrides -->
    <link rel="stylesheet" href="css/custom.css">

    <link rel="stylesheet" href="lib/css/darcula.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h3>Property-Based Testing of Browser Rendering Engines with a Consensus Oracle</h3>
          <p><font color="#ffea9a">COMPSAC 2018</font></p>
          <ul style="list-style: none">
            <li><font color="green">Joel Martin</font>
              <ul style="list-style: none">
                <li>University of Texas, Arlington
                  <li>ViaSat, Inc
              </ul>
            <li><font color="green">David Levine</font>
              <ul style="list-style: none">
                <li>Univeristy of Texas, Arlington
              </ul>
          </ul>
          <!-- <p><i>Press 's' to show speaker notes</i></p> -->
          <aside class="notes">
            <ul>
              <li>Silence phone
              <li>
                Good morning everyone!

                My name is Joel Martin. I'm a Principal Software Engineer at
                ViaSat, Inc and I am also a PhD candidate at the University of
                Texas, Arlington. My co-author on this paper is David Levine from
                the University of Texas, Arlington. The title of this paper is
                'Property-Based Testing of Browser Rendering Engines with
                a Consensus Oracle'
            </ul>
          </aside>
        </section>
        <section>
          <section>
            <h3>The Problem</h3>
            <ul>
              <li class="fragment">The Test Oracle Problem</li>
            </ul>
            <aside class="notes">
              <ul>
                <li>
                  The are some systems where determining correct
                  behavior is difficult. To be more precise: there
                  exists a class of systems under test for which the
                  process of determining the correct output based on
                  a given input has a similar order of complexity to
                  the system under test itself. This is the Test
                  Oracle Problem
                  <font color="green"> [show fragment #1]</font>. Our
                  paper proposes an approach to address this problem
                  in the context of browser render testing. I'll also
                  discuss ways in which the approach is more broadly
                  applicable to systems beyond browser rendering.
              </ul>
            </aside>
          </section>
          <section>
            <h3>Browser Rendering</h3>
<!--
<html>
  <body style="background: #1289af">
    <div style="left: 10%; width: 20%;
                font: 25px/1 rgba(100,100,100,0.5)">
      Pythia, Apollo, Dione.
    </div>
  </body>
</html>
-->
<!--<code class="hlhtml" data-trim>-->
            <div style="position:relative">
              <pre style="position:absolute" class="fragment"><code class="html" data-noescape>
&lt;html&gt;
  &lt;body style="background: #1289af"&gt;
    &lt;div style="left: 10%; width: 20%;
                font: 'Fira Sans' 25px/1
                      rgba(100,100,100,0.5)"&gt;
      Pythia, Apollo, Dione.
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
              </code></pre>
              <pre style="position:absolute" class="fragment"><code class="html" data-noescape>
&lt;html&gt;
  &lt;body style="background: #1289af"&gt;
    &lt;div style="<mark>left: 10%; width: 20%;</mark>
                font: 'Fira Sans' 25px/1
                      rgba(100,100,100,0.5)"&gt;
      Pythia, Apollo, Dione.
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
              </code></pre>
              <pre style="position:absolute" class="fragment"><code class="html" data-noescape>
&lt;html&gt;
  &lt;body style="background: #1289af"&gt;
    &lt;div style="left: 10%; width: 20%;
                font: <mark>'Fira Sans'</mark> 25px/1
                      rgba(100,100,100,0.5)"&gt;
      Pythia, Apollo, Dione.
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
              </code></pre>
              <pre style="position:absolute" class="fragment"><code class="html" data-noescape>
&lt;html&gt;
  &lt;body style="<mark>background: #1289af</mark>"&gt;
    &lt;div style="left: 10%; width: 20%;
                font: 'Fira Sans' 25px/1
                      <mark>rgba(100,100,100,0.5)</mark>"&gt;
      Pythia, Apollo, Dione.
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
              </code></pre>
              <pre style="position:absolute" class="fragment"><code class="html" data-noescape>
&lt;html&gt;
  &lt;body style="background: #1289af"&gt;
    &lt;div style="left: 10%; width: 20%;
                font: <mark>'Fira Sans' 25px/1</mark>
                      rgba(100,100,100,0.5)"&gt;
      <mark>Pythia, Apollo, Dione.</mark>
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
              </code></pre>
            </div>
            <aside class="notes">
              <ul>
                <li>
                  Let's consider a browser rendering test case.
                  <font color="green">[show fragment #1]</font> Even
                  though this web page is fairly simple compared to
                  real-world web pages, it is still non-trivial to
                  verify that a browser has rendered this page
                  correctly. There are a number of reasons for this:
                  <ul>
                    <li><font color="green">[show fragment #2]</font>
                      The CSS element sizing and positioning
                      standard is large and nuanced (and one of the
                      basic things we would like to test)
                    <li><font color="green">[show fragment #3]</font>
                      environment factors: browser window geometry,
                      available OS fonts 
                    <li><font color="green">[show fragment #4]</font>
                      color model and alpha blending 
                    <li><font color="green">[show fragment #5]</font>
                      font rendering model (especially spacing
                      issues like kerning which may cause other page
                      elements to shift significantly)
                  </ul>
                  Current solutions to browser render testing often
                  involve manual user intervention at some stage of
                  the process and use a highly constrained test
                  environment. The goal of our approach is a browser
                  render testing system that is both comprehensive and
                  fully automated.
              </ul>
            </aside>
          </section>
        </section>
        <section>
          <h3>A Solution</h3>
          <ul>
            <li class="fragment">Property-Based Testing (PBT)</li>
            <li class="fragment">Grammar-based Input Generators</li>
            <li class="fragment">Consensus Oracle</li>
          </ul>
          <aside class="notes">
            There are three main components to our approach.
            Property-based testing, grammar-based input generators,
            and a consensus oracle. Let's consider each one in turn.
          </aside>
        </section>
        <section>
          <section>
            <h3>Property-Based Testing (PBT)</h3>
            <ul>
              <li>Popularized by QuickCheck<br>
                (Claessen &amp; Hughes, 2000)
              <li>Input properties are defined in terms of generators
              <li>Output properties define success/failure (e.g. test Oracle)
              <li>Grow "size" of input properties until output
                properties violated (test failure)
            </ul>
            <aside class="notes">
              <ul>
                <li>Property-based testing is a testing methodology
                  that was popularized by the QuickCheck system
                  developed by Koen Claessen and John Hughes in 2000.
                <li>In property-based testing the tester defines
                  properties or assertions about the inputs values and
                  output values of the system under test.
                <li>Typical PBT systems define input properties in
                  terms of generator functions. Each generator
                  function takes a size value which has a generator
                  specific meaning. Generators are combined to create
                  compound generators which can be recursive.
                <li>Output properties are used by the test system to
                  validate outputs for a given set of inputs. When
                  test results violate the output properties the
                  corresponding inputs are considered a failing test
                  case.
                <li>A single run of property-based testing involves
                  calling the input properties with larger and larger
                  size values to stochastically generate large and
                  large test cases until the output properties are
                  violated.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>PBT Test Shrinking</h3>
            <ul>
              <li>Each test case is a tree of generator nodes.
              <li>Pick nodes in the tree and try smaller size values.
              <li>Gradient descent walk to find "smallest" test failure
              <li>Extremely important for complex compound generators
                (e.g. recursive)
            </ul>
            <aside class="notes">
              <ul>
                <li>Hard to overstate the importance of test
                  shrinking. The highly recursive nature of the HTML
                  grammar means that generated test cases can become
                  before large.
                <li>There is a positive aspect to this in that large
                  cases can each achieve non-trivial code coverage of
                  the system under test.
                <li>The major downside to this is that large test
                  cases are not helpful to the tester in doing root
                  cause analysis.
                <li>Test shrinking can significantly reduce the size
                  of the test case while still preserving the
                  failure in the system under test.
                <li>Now let's look at a simple PBT example.
              </ul>
            </aside>
        </section>
          <section data-transition="none">
            <h3>Simple PBT Example</h3>
            <div style="position:absolute">
              <ul>
                <li>Input property: P is a sequence of integers</li>
                <li>Output property: sum of integers in P <font style="visibility: hidden" color="green">(almost)</font></li>
              </ul>
              <pre class="fragment"><code class="clojure" data-noescape>> (def SUT
    (fn [x] (apply + x)))

> (tc/quick-check 10
    (props/for-all
      [P (gen/vector gen/int)]
      (= (SUT P) (apply + P))))
{:result true,
 :num-tests 10}



              </code></pre>
            </div>
            <aside class="notes">
              <ul>
                <li>Let's consider a simple example.
                <li>We define the input property as a sequence of
                  integers.
                <li>The output property states that the output from
                  running the SUT on the input property should be
                  a value that is the sum of the values in input
                  sequence.
                <li><font color="green">[show fragment #5]</font>
                  Here is code showing what this would look like coded
                  with Clojure's test.check library. Namespace imports
                  have been elided.
                <li>First we define the SUT to be the application of
                  sum to a sequence.
                <li>Then we define our properties using the props-all
                  function and pass this to the quick-check function
                  to run 10 test iterations.
                <li>The input property P is defined as a compound
                  generator which generates a vector of integers.
                <li>The output property states that the execution of
                  the SUT on P should have the exact same result
                  as apply sum to the values in P.
                <li>The final two lines are the result of the test
                  showing that all 10 iterations were run with no
                  property violations.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Simple PBT Example</h3>
            <div style="position:absolute">
              <ul>
                <li>Input property: P is a sequence of integers</li>
                <li>Output property: sum of integers in P <font style="visibility: hidden" color="green">(almost)</font></li>
              </ul>
              <pre><code class="clojure" data-noescape>> (def SUT
    (fn [x] (apply + x)))

> (tc/quick-check 100
    (props/for-all
      [P (gen/vector gen/int)]
      (= (SUT P) (apply + P))))
{:result true,
 :num-tests 100}



              </code></pre>
            </div>
            <aside class="notes">
              <ul>
                <li>We can increase the number of iterations to 100
                  and see that the result is unchanged. Which is not
                  surprising since our test Oracle output property and
                  the SUT are currently defined identically.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Simple PBT Example</h3>
            <div style="position:absolute">
              <ul>
                <li>Input property: P is a sequence of integers</li>
                <li>Output property: sum of integers in P <font color="green">(almost)</font></li>
              </ul>
              <pre><code class="clojure" data-noescape>> (def SUT
    (fn [x] (if (<= 13 (count x) 17) 0 (apply + x))))

> (tc/quick-check 10
    (props/for-all
      [P (gen/vector gen/int)]
      (= (SUT P) (apply + P))))
{:result true,
 :num-tests 10}



              </code></pre>
            </div>
            <aside class="notes">
              <ul>
                <li>Now let's introduce a bug in our SUT such that
                  a sequence containing 13 to 17 integers will result
                  in the value 0 being returned instead of the sum.
                <li>Our properties remain unchanged.
                <li>We can see that running 10 iterations still passed
                  because the sizes being generated P are still small
                  and no sequence long enough to trigger the bug is
                  generated.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Simple PBT Example</h3>
            <div style="position:absolute">
              <ul>
                <li>Input property: P is a sequence of integers</li>
                <li>Output property: sum of integers in P <font color="green">(almost)</font></li>
              </ul>
              <pre><code class="clojure" data-noescape>> (def SUT
    (fn [x] (if (<= 13 (count x) 17) 0 (apply + x))))

> (tc/quick-check 100
    (props/for-all
      [P (gen/vector gen/int)]
      (= (SUT P) (apply + P))))
{:result false,
 :num-tests 31,
 :fail [[1 19 12 18 -7 30 -8 15
         13 -15 8 -3 1 -21 10 19]],
 :shrunk {:total-nodes-visited 262,
          :smallest [[0 0 0 0 0 0 0 0 0 0 0 0 0]]}} </code></pre>
            </div>
            <aside class="notes">
              <ul>
                <li>However, running with a maximum of 100 iterations
                  triggers a test case failure on the 31st iteration.
                <li>The initial input property which triggered the
                  failure has 16 elements. <!-- TODO: highlight -->
                <li>After the failure was discovered, the quick-check
                  function ran an addition 262 test shrink iterations
                  and found that a sequence of 13 zeros that triggers
                  the failure.
              </ul>
            </aside>
          </section>
        </section>
        <section data-transition="none">
          <section>
            <h3>Grammar-based Input Generators</h3>
            <ul>
              <li>Test Case Composition (web pages):
                <ul>
                  <li>HTML (content)
                  <li>CSS (presentation)
                </ul>
              <li class="fragment">Goals
                <ul>
                  <li>Comprehensive
                  <li>Automated
                  <li>Controllable
                </ul>
            </ul>
            <aside class="notes">
              <ul>
                <li>Now let's talk about the the input properties for
                  browser render testing. In this case we want to
                  generate web pages which mean generating HTML and
                  CSS. These basically represent the content and
                  presentation respectively. The third component of
                  web page is the behavior defined in JavaScript but
                  that is not in scope for our paper.
                <li><font color="green">[show fragment #1]</font>
                  The are several goal we want for our generators:
                  <ul>
                    <li><b>Comprehensive</b>: we want web pages that cover
                      the whole domain valid web pages. So generators
                      themselves are generated from raw data from
                      upstream HTML and CSS standards.
                    <li><b>Automated</b>: already mentioned that we want
                      automated creation of the generators themselves,
                      but we also want the generators output full
                      web pages that don't require human final
                      assembly or tweaking.
                    <li><b>Controllable</b>: Because the domain of valid web
                      pages is essentially unbounded, we want the
                      tester to have the ability to choose more narrow
                      domains to focus on.
                  </ul>
              </ul> 
            </aside>
          </section>
          <section>
            <h3>Grammar-Based Generators</h3>
            <ul>
              <li class="fragment">W3C Standards &rarr; Data
              <li class="fragment">Data &rarr; EBNF
              <li class="fragment">EBNF &rarr; Generators
              <li class="fragment">Generators &rarr; HTML+CSS
            </ul>
            <aside class="notes">
              <ul>
                <li><font color="green">[show fragment #1]</font>
                  Our basic approach is to use first download and
                  normalize HTML and CSS specification data.
                <li><font color="green">[show fragment #1]</font>
                  Then we load that data and use it to generate
                  EBNF grammars that can parse web pages containing
                  HTML and CSS.
                <li><font color="green">[show fragment #1]</font>
                  Then we parse the EBNF grammar files and output
                  generator functions for each of the rules in the
                  grammar.
              </ul> 
            </aside>
          </section>
          <section>
            <h3>HTML 5</h3>
            <ul>
              <li>W3C Standard
              <li>130 tag elements
              <li>110 tag attributes
            </ul>
            <aside class="notes">
              <ul>
                <li>Specifically version 5 of the standard
                <li><font color="green">[show fragment #1]</font>
                  <ul>
                    <li>
                  </ul>
              </ul> 
            </aside>
          </section>
          <section data-transition="none-out">
            <h3>HTML Elements</h3>
            <pre><code class="html" data-noescape>
&lt;div&gt; div content &lt;/div&gt;
&lt;span&gt; span content &lt;/span&gt;
&lt;body&gt; body of page &lt;/body&gt;
&lt;b&gt; bold text &lt;/b&gt;
            </code></pre>
          </section>
          <section data-transition="none-in">
            <h3>HTML Elements</h3>
            <pre><code class="html" data-noescape>
&lt;<mark>div</mark>&gt; div content &lt;/<mark>div</mark>&gt;
&lt;<mark>span</mark>&gt; span content &lt;/<mark>span</mark>&gt;
&lt;<mark>body</mark>&gt; body of page &lt;/<mark>body</mark>&gt;
&lt;<mark>b</mark>&gt; bold text &lt;/<mark>b</mark>&gt;
            </code></pre>
          </section>
          <section data-transition="none-out">
            <h3>HTML Attributes</h3>
            <pre><code class="html"  data-noescape>
&lt;div style="text-color: red"&gt; div containing red text &lt;/div&gt;
&lt;div class="myclass1"&gt; div with class myclass1 &lt;/div&gt;
&lt;div id="mydiv1"&gt; div with ID mydiv1 &lt;/div&gt;
&lt;span lang="en"&gt; English language text &lt;/span&gt;
&lt;a href="http://w3c.org"&gt; W3C link &lt;/a&gt;
            </code></pre>
          </section>
          <section data-transition="none-in">
            <h3>HTML Attributes</h3>
            <pre><code class="html"  data-noescape>
&lt;div <mark>style="text-color: red"</mark>&gt; div containing red text &lt;/div&gt;
&lt;div <mark>class="myclass1"</mark>&gt; div with class myclass1 &lt;/div&gt;
&lt;div <mark>id="mydiv1"</mark>&gt; div with ID mydiv1 &lt;/div&gt;
&lt;span <mark>lang="en"</mark>&gt; English language text &lt;/span&gt;
&lt;a <mark>href="http://w3c.org"</mark>&gt; W3C link &lt;/a&gt;
            </code></pre>
          </section>
          <section>
            <h3>CSS 3</h3>
            <ul>
              <li>W3C Standard
              <li>50 sub-specifications (modules)
              <li>360 CSS properties
            </ul>
            <aside class="notes">
              <ul>
                <li>Specifically version 3 of the standard.
                <li>50 different sub-specifications referred to as
                  CSS3 modules which are in various stages of
                  standardization.
                <li>There are more than 360 CSS property names across
                  all the CSS3 modules.
              </ul>
            </aside>
          </section>
          <section>
            <h3>CSS Value Definition Syntax (VDS)</h3>
            <ul>
              <li>VDS:
            <pre><code class="css overflow"  data-noescape><'text-emphasis-position'> =
  [ over | under ] && [ right | left ]
            </code></pre>
              <li>EBNF:
            <pre><code class="bash overflow"  data-noescape>prop-text-emphasis-position =
  ( ( 'over' ' ' | 'under' ' ') ' '
    ( 'right' ' ' | 'left' ' ') ' ' ) ;
            </code></pre>
          </section>
          <section>
            <h3>CSS Value Definition Syntax (VDS)</h3>
            <ul>
              <li>Generator:
            <pre><code class="clojure overflow"  data-noescape>(gen/tuple
  (gen/return " ")
  (gen/frequency [
    [100
      (gen/tuple (gen/return " ") (gen/return "over"))]
    [100
      (gen/tuple (gen/return " ") (gen/return "under"))]])
  (gen/return " ")
  (gen/frequency [
    [100
      (gen/tuple (gen/return " ") (gen/return "right"))]
    [100
      (gen/tuple (gen/return " ") (gen/return "left"))]]))
            </code></pre>
            </ul>
            <aside class="notes">
              <ul>
                <li>And here is the final test.check generator for that rule.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Controlling the Grammar</h3>
            <ul>
              <li>Generator:
            <pre><code class="clojure overflow"  data-noescape>(gen/tuple
  (gen/return " ")
  (gen/frequency [
    [100                                                          &nbsp;
      (gen/tuple (gen/return " ") (gen/return "over"))]
    [100
      (gen/tuple (gen/return " ") (gen/return "under"))]])
  (gen/return " ")
  (gen/frequency [
    [100
      (gen/tuple (gen/return " ") (gen/return "right"))]
    [100
      (gen/tuple (gen/return " ") (gen/return "left"))]]))
            </code></pre>
            </ul>
            <aside class="notes">
              <ul>
                <li>Here is the grammar I showed earlier.
                <li>This is actually omitting the extra parts that
                  allow the grammar to be controlled or tuned
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Controlling the Grammar</h3>
            <ul>
              <li>Generator:
            <pre><code class="clojure overflow"  data-noescape>(gen/tuple
  (gen/return " ")
  (gen/frequency [
    [(get weights [:prop-text-emphasis-position :cat 1 :alt 0] 100)
      (gen/tuple (gen/return " ") (gen/return "over"))]
    [(get weights [:prop-text-emphasis-position :cat 1 :alt 1] 100)
      (gen/tuple (gen/return " ") (gen/return "under"))]])
  (gen/return " ")
  (gen/frequency [
    [(get weights [:prop-text-emphasis-position :cat 3 :alt 0] 100)
      (gen/tuple (gen/return " ") (gen/return "right"))]
    [(get weights [:prop-text-emphasis-position :cat 3 :alt 1] 100)
      (gen/tuple (gen/return " ") (gen/return "left"))]]))
            </code></pre>
            </ul>
            <aside class="notes">
              <ul>
                <li>
              </ul>
            </aside>
          </section>
        </section>
        </section>
        <section data-transition="none">
          <section>
            <h3>Consensus Oracle</h3>
            <aside class="notes">
              <ul>
                <li>
                <li><font color="green">[show fragment #1]</font>
                  <ul>
                    <li>
                  </ul>
              </ul> 
            </aside>
          </section>
          <section>
            <img src="imgs/results1.png" width=80%></img>
          </section>
          <section>
            <img src="imgs/results1_expanded.png" width=80%></img>
          </section>
          <section>
            <table>
              <tr>
                <td style="border: 0px">
                  <img src="imgs/results1_7_firefox.png"
                       style="margin: 5px"></img>
                </td>
                <td style="border: 0px">
                  <img src="imgs/results1_7_diff_firefox_chrome.png"
                       style="margin: 5px; transform: translateY(-15%)"></img>
                </td>
                <td style="border: 0px">
                  <img src="imgs/results1_7_chrome.png"
                       style="margin: 5px"></img>
                </td>
              </tr>
              <tr>
                <td style="border: 0px">
                  <img src="imgs/results1_7_diff_chrome_servo.png"
                       style="margin: 5px"></img>
                </td>
                <td style="border: 0px">
                  <img src="imgs/results1_7_servo.png"
                       style="margin: 5px; transform: translateY(15%)"></img>
                </td>
                <td style="border: 0px">
                  <img src="imgs/results1_7_diff_firefox_servo.png"
                       style="margin: 5px"></img>
                </td>
              </tr>
            </table>
          </section>
        </section>
        <section>
          <h3>Results</h3>
            <aside class="notes">
              <ul>
                <li>
                <li><font color="green">[show fragment #1]</font>
                  <ul>
                    <li>
                  </ul>
              </ul> 
            </aside>
        </section>
        <section>
          <h3>Questions?</h3>
            <aside class="notes">
              <ul>
                <li>
                <li><font color="green">[show fragment #1]</font>
                  <ul>
                    <li>
                  </ul>
              </ul> 
            </aside>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>

<!-- vim: ts=2:sw=2:set expandtab -->
