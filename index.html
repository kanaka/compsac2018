<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>COMPSAC 2018 - Property-Based Testing of Browser Rendering Engines with a Consensus Oracle</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <!-- <link rel="stylesheet" href="lib/css/zenburn.css"> -->

    <!-- Custom overrides -->
    <link rel="stylesheet" href="css/custom.css">

    <link rel="stylesheet" href="lib/css/darcula.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h3>Property-Based Testing of Browser Rendering Engines with a Consensus Oracle</h3>
          <p><font color="#ffea9a">COMPSAC 2018</font></p>
          <ul style="list-style: none">
            <li><font color="green">Joel Martin</font>
              <ul style="list-style: none">
                <li>University of Texas, Arlington
                  <li>ViaSat, Inc
              </ul>
            <li><font color="green">David Levine</font>
              <ul style="list-style: none">
                <li>Univeristy of Texas, Arlington
              </ul>
          </ul>
          <!-- <p><i>Press 's' to show speaker notes</i></p> -->
          <aside class="notes">
            <ul>
              <li>Silence phone
              <li>
                Good morning everyone!

                My name is Joel Martin. I'm a Principal Software Engineer at
                ViaSat, Inc and I am also a PhD candidate at the University of
                Texas, Arlington. My co-author on this paper is David Levine from
                the University of Texas, Arlington. The title of this paper is
                'Property-Based Testing of Browser Rendering Engines with
                a Consensus Oracle'
            </ul>
          </aside>
        </section>
        <section>
          <section>
            <h2>The Problem</h2>
            <ul>
              <li class="fragment" style="list-style: none"><font color="green">The Test Oracle Problem</font></li>
            </ul>
            <aside class="notes">
              <ul>
                <li>
                  The are some systems where determining correct
                  behavior during testing is difficult. To be more
                  precise: there exists a class of systems under test
                  for which the process of determining the correct
                  output based on a given input has a similar order of
                  complexity to the system under test itself. This is
                  the Test Oracle Problem
                  <font color="green"> [show fragment #1]</font>. Our
                  paper proposes an approach to address this problem
                  in the context of browser render testing.
              </ul>
            </aside>
          </section>
          <section>
            <h3>Browser Rendering</h3>
            <div style="position:relative">
              <pre style="position:absolute" class="fragment"><code class="html" data-noescape>
&lt;html&gt;
  &lt;body style="background: #1289af"&gt;
    &lt;div style="left: 10%; width: 20%;
                font: 'Fira Sans' 25px/1
                      rgba(100,100,100,0.5)"&gt;
      Pythia, Apollo, Dione.
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
              </code></pre>
              <pre style="position:absolute" class="fragment"><code class="html" data-noescape>
&lt;html&gt;
  &lt;body style="background: #1289af"&gt;
    &lt;div style="<mark>left: 10%; width: 20%;</mark>
                font: 'Fira Sans' 25px/1
                      rgba(100,100,100,0.5)"&gt;
      Pythia, Apollo, Dione.
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
              </code></pre>
              <pre style="position:absolute" class="fragment"><code class="html" data-noescape>
&lt;html&gt;
  &lt;body style="background: #1289af"&gt;
    &lt;div style="left: 10%; width: 20%;
                font: <mark>'Fira Sans'</mark> 25px/1
                      rgba(100,100,100,0.5)"&gt;
      Pythia, Apollo, Dione.
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
              </code></pre>
              <pre style="position:absolute" class="fragment"><code class="html" data-noescape>
&lt;html&gt;
  &lt;body style="<mark>background: #1289af</mark>"&gt;
    &lt;div style="left: 10%; width: 20%;
                font: 'Fira Sans' 25px/1
                      <mark>rgba(100,100,100,0.5)</mark>"&gt;
      Pythia, Apollo, Dione.
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
              </code></pre>
              <pre style="position:absolute" class="fragment"><code class="html" data-noescape>
&lt;html&gt;
  &lt;body style="background: #1289af"&gt;
    &lt;div style="left: 10%; width: 20%;
                font: <mark>'Fira Sans' 25px/1</mark>
                      rgba(100,100,100,0.5)"&gt;
      <mark>Pythia, Apollo, Dione.</mark>
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
              </code></pre>
            </div>
            <aside class="notes">
              <ul>
                <li>
                  Let's consider a browser rendering test case.
                  <font color="green">[show fragment #1]</font> Even
                  though this web page is fairly simple compared to
                  real-world web pages, it is still non-trivial to
                  verify that a browser has rendered this page
                  correctly. There are a number of reasons for this:
                  <ul>
                    <li><font color="green">[show fragment #2]</font>
                      The CSS element sizing and positioning
                      standard is large and nuanced (and one of the
                      basic things we would like to test)
                    <li><font color="green">[show fragment #3]</font>
                      environment factors: browser window geometry,
                      available OS fonts 
                    <li><font color="green">[show fragment #4]</font>
                      color model and alpha blending 
                    <li><font color="green">[show fragment #5]</font>
                      font rendering model (especially spacing
                      issues like kerning which may cause other page
                      elements to shift significantly)
                  </ul>
                  Current solutions to browser render testing often
                  involve manual user intervention at some stage of
                  the process and use a highly constrained test
                  environment. The goal of our approach is a browser
                  render testing system that is both comprehensive and
                  fully automated.
              </ul>
            </aside>
          </section>
        </section>
        <section>
          <h2>A Solution</h2>
          <ul>
            <li class="fragment">Property-Based Testing (PBT)</li>
            <li class="fragment">Grammar-based Input Generators</li>
            <li class="fragment">Consensus Oracle</li>
          </ul>
          <aside class="notes">
            There are three main components to our approach.
            Property-based testing, grammar-based input generators,
            and a consensus oracle. Let's consider each one in turn.
          </aside>
        </section>
        <section>
          <section>
            <h2>Property-Based Testing (PBT)</h2>
            <ul>
              <li>QuickCheck (Claessen &amp; Hughes, 2000)
              <li>Input properties are defined in terms of generators
              <li>Output properties define success (e.g. test Oracle)
              <li>Output property violations indicate test failure
              <li>Grow "size" of input properties until output
                properties violated
            </ul>
            <aside class="notes">
              <ul>
                <li>Property-based testing is a testing methodology
                  that was popularized by the QuickCheck system
                  developed by Koen Claessen and John Hughes in 2000.
                <li>In property-based testing the tester defines
                  properties or assertions about the inputs values and
                  output values of the system under test.
                <li>Typical PBT systems define input properties in
                  terms of generator functions. Each generator
                  function takes a size value which has a generator
                  specific meaning. Generators are combined to create
                  compound generators which can be recursive.
                <li>Output properties are used by the test system to
                  validate outputs for a given set of inputs. When
                  test results violate the output properties the
                  corresponding inputs are considered a failing test
                  case.
                <li>A single run of property-based testing involves
                  calling the input properties with larger and larger
                  size values to stochastically generate large and
                  large test cases until the output properties are
                  violated.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>PBT Test Shrinking</h3>
            <ul>
              <li>Tree of generator nodes
              <li>Pick node, try small size value
              <li>Gradient descent walk to the "smallest" tree
              <li>Critical for compound/recursive generators
            </ul>
            <aside class="notes">
              <ul>
                <li>Each test case is a tree of generator nodes.
                <li>Pick nodes in the tree and try smaller size values.
                <li>Gradient descent walk to find "smallest" test failure
                <li>Extremely important for complex compound
                  generators (e.g. recursive)
                <li>Hard to overstate the importance of test
                  shrinking. The highly recursive nature of the HTML
                  grammar means that generated test cases can become
                  before large.
                <li>There is a positive aspect to this in that large
                  cases can each achieve non-trivial code coverage of
                  the system under test.
                <li>The major downside to this is that large test
                  cases are not helpful to the tester in doing root
                  cause analysis.
                <li>Test shrinking can significantly reduce the size
                  of the test case while still preserving the
                  failure in the system under test.
                <li>Now let's look at a simple PBT example.
              </ul>
            </aside>
        </section>
          <section data-transition="none">
            <h3>Simple PBT Example</h3>
            <div style="position:absolute">
              <ul>
                <li>Input property: P is a sequence of integers</li>
                <li>Output property: sum of integers in P <font style="visibility: hidden" color="green">(almost)</font></li>
              </ul>
              <pre class="fragment"><code class="clojure" data-noescape>> (def SUT
    (fn [x] (apply + x)))

> (tc/quick-check 10
    (props/for-all
      [P (gen/vector gen/int)]
      (= (SUT P) (apply + P))))
{:result true,
 :num-tests 10}



              </code></pre>
            </div>
            <aside class="notes">
              <ul>
                <li>Let's consider a simple example.
                <li>We define the input property as a sequence of
                  integers.
                <li>The output property states that the output from
                  running the SUT on the input property should be
                  a value that is the sum of the values in input
                  sequence.
                <li><font color="green">[show fragment #5]</font>
                  Here is code showing what this would look like coded
                  with Clojure's test.check library. Namespace imports
                  have been elided.
                <li>First we define the SUT to be the application of
                  sum to a sequence.
                <li>Then we define our properties using the props-all
                  function and pass this to the quick-check function
                  to run 10 test iterations.
                <li>The input property P is defined as a compound
                  generator which generates a vector of integers.
                <li>The output property states that the execution of
                  the SUT on P should have the exact same result
                  as apply sum to the values in P.
                <li>The final two lines are the result of the test
                  showing that all 10 iterations were run with no
                  property violations.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Simple PBT Example</h3>
            <div style="position:absolute">
              <ul>
                <li>Input property: P is a sequence of integers</li>
                <li>Output property: sum of integers in P <font style="visibility: hidden" color="green">(almost)</font></li>
              </ul>
              <pre><code class="clojure" data-noescape>> (def SUT
    (fn [x] (apply + x)))

> (tc/quick-check 100
    (props/for-all
      [P (gen/vector gen/int)]
      (= (SUT P) (apply + P))))
{:result true,
 :num-tests 100}



              </code></pre>
            </div>
            <aside class="notes">
              <ul>
                <li>We can increase the number of iterations to 100
                  and see that the result is unchanged. Which is not
                  surprising since our test Oracle output property and
                  the SUT are currently defined identically.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Simple PBT Example</h3>
            <div style="position:absolute">
              <ul>
                <li>Input property: P is a sequence of integers</li>
                <li>Output property: sum of integers in P <font color="green">(almost)</font></li>
              </ul>
              <pre><code class="clojure" data-noescape>> (def SUT
    (fn [x] (if (<= 13 (count x) 17) 0 (apply + x))))

> (tc/quick-check 10
    (props/for-all
      [P (gen/vector gen/int)]
      (= (SUT P) (apply + P))))
{:result true,
 :num-tests 10}



              </code></pre>
            </div>
            <aside class="notes">
              <ul>
                <li>Now let's introduce a bug in our SUT such that
                  any sequence containing 13 to 17 integers will
                  result in the value 0 being returned instead of the
                  sum.
                <li>Our properties remain unchanged.
                <li>We can see that running 10 iterations still passed
                  because the sizes being generated P are still small
                  and no sequence long enough to trigger the bug is
                  generated.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Simple PBT Example</h3>
            <div style="position:absolute">
              <ul>
                <li>Input property: P is a sequence of integers</li>
                <li>Output property: sum of integers in P <font color="green">(almost)</font></li>
              </ul>
              <pre><code class="clojure" data-noescape>> (def SUT
    (fn [x] (if (<= 13 (count x) 17) 0 (apply + x))))

> (tc/quick-check 100
    (props/for-all
      [P (gen/vector gen/int)]
      (= (SUT P) (apply + P))))
{:result false,
 :num-tests 31,
 :fail [[1 19 12 18 -7 30 -8 15
         13 -15 8 -3 1 -21 10 19]],
 :shrunk {:total-nodes-visited 262,
          :smallest [[0 0 0 0 0 0 0 0 0 0 0 0 0]]}} </code></pre>
            </div>
            <aside class="notes">
              <ul>
                <li>However, running with a maximum of 100 iterations
                  triggers a test case failure on the 31st iteration.
                <li>The initial input property which triggered the
                  failure contained 16 integers. <!-- TODO: highlight -->
                <li>After the failure was discovered, the quick-check
                  function ran an addition 262 test shrink iterations
                  and found that a sequence of 13 zeros that triggers
                  the failure. This is the smallest test case that was
                  found that still triggered the failure.
              </ul>
            </aside>
          </section>
        </section>
        <section data-transition="none">
          <section>
            <h2>Input Generators</h2>
            <ul>
              <li>Test Case Composition (web pages):
                <ul>
                  <li>HTML (content)
                  <li>CSS (presentation)
                </ul>
              <li class="fragment">Goals:
                <ul>
                  <li>Automated
                  <li>Controllable
                  <!--<li>Comprehensive-->
                </ul>
            </ul>
            <aside class="notes">
              <ul>
                <li>Now let's talk about the the input properties for
                  browser render testing. In this case we want to
                  generate web pages which mean generating HTML and
                  CSS. These basically represent the content and
                  presentation respectively. The third component of
                  web page is the behavior defined in JavaScript but
                  that is not in scope for our paper.
                <li><font color="green">[show fragment #1]</font>
                  The are several goal we want for our generators:
                  <ul>
                    <li><b>Automated</b>: already mentioned that we want
                      automated creation of the generators themselves,
                      but we also want the generators output full
                      web pages that don't require human final
                      assembly or tweaking.
                    <li><b>Controllable</b>: Because the domain of valid web
                      pages is essentially unbounded, we want the
                      tester to have the ability to choose more narrow
                      domains to focus on.
                    <!--
                    <li><b>Comprehensive</b>: we want web pages that cover
                      the whole domain valid web pages. So generators
                      themselves are generated from raw data from
                      upstream HTML and CSS standards.
                    -->
                  </ul>
              </ul> 
            </aside>
          </section>
          <section>
            <h3>Grammar-Based Generators</h3>
            <ul>
              <li class="fragment">W3C Standards &rarr; Data
              <li class="fragment">Data &rarr; EBNF
              <li class="fragment">EBNF &rarr; Generators
              <li class="fragment">Generators &rarr; HTML+CSS
            </ul>
            <aside class="notes">
              <ul>
                <li><font color="green">[show fragment #1]</font>
                  Our basic approach is to use first download and
                  normalize HTML and CSS specification data.
                <li><font color="green">[show fragment #1]</font>
                  Then we load that data and use it to generate
                  EBNF grammars that can parse web pages containing
                  HTML and CSS.
                <li><font color="green">[show fragment #1]</font>
                  Then we parse the EBNF grammar files and output
                  generator functions for each of the rules in the
                  grammar.
                <li><font color="green">[show fragment #1]</font>
                  Finally, the PBT test harness is able to use the
                  generators for our input properties to generate HTML
                  and CSS test cases.
              </ul> 
            </aside>
          </section>
          <section>
            <h3>HTML 5</h3>
            <ul>
              <li>W3C Standard
              <li>130 Elements (tags)
              <li>110 Attributes
            </ul>
            <aside class="notes">
              <ul>
                <li>Let's talk briefly about HTML. HTML is a World
                  Wide Web Consortium standard. HTML 5 is the current
                  major version of the standard.
                <li>HTML is composed of two major parts: elements and
                  attributes.
                <li>The standard defines approximate 130 HTML elements
                  and 110 attributes.
              </ul> 
            </aside>
          </section>
          <section data-transition="none-out">
            <h3>HTML Example</h3>
            <pre><code class="html" data-noescape>&lt;html&gt;
  &lt;body&gt;
    page document body
    &lt;div&gt; div content &lt;/div&gt;
    &lt;span class="myclass1"&gt; span content &lt;/span&gt;
    &lt;div id="mydiv1"&gt; div content &lt;/div&gt;
    &lt;b style="text-color: red"&gt; bold red text &lt;/b&gt;
    &lt;div&gt;
      &lt;b&gt; bold text within a div &lt;/b&gt;
      &lt;span&gt; span content within a div &lt;/span&gt;
    &lt;/div&gt;
    &lt;a href="http://w3c.org"&gt; text of link to W3C &lt;/a&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
            <aside class="notes">
              <ul>
                <li>Here is an example web page container HTML
                <li>There are two major components of HTML ...
              </ul> 
            </aside>
          </section>
          <section data-transition="none-in">
            <h3>HTML Example</h3>
            <pre><code class="html" data-noescape>&lt;<mark>html</mark>&gt;
  &lt;<mark>body</mark>&gt;
    page document body
    &lt;<mark>div</mark>&gt; div content &lt;/<mark>div</mark>&gt;
    &lt;<mark>span</mark> class="myclass1"&gt; span content &lt;/<mark>span</mark>&gt;
    &lt;<mark>div</mark> id="mydiv1"&gt; div content &lt;/<mark>div</mark>&gt;
    &lt;<mark>b</mark> style="text-color: red"&gt; bold red text &lt;/<mark>b</mark>&gt;
    &lt;<mark>div</mark>&gt;
      &lt;<mark>b</mark>&gt; bold text within a div &lt;/<mark>b</mark>&gt;
      &lt;<mark>span</mark>&gt; span content within a div &lt;/<mark>span</mark>&gt;
    &lt;/<mark>div</mark>&gt;
    &lt;<mark>a</mark> href="http://w3c.org"&gt; text of link to W3C &lt;/<mark>a</mark>&gt;
  &lt;/<mark>body</mark>&gt;
&lt;/<mark>html</mark>&gt;</code></pre>
            </code></pre>
            <aside class="notes">
              <ul>
                <li>First: elements which are delineated by tags.
                <li>Note that the grammar for HTML elements is
                  recursive and permits elements to be contained
                  within other elements.
              </ul> 
            </aside>
          </section>
          <section data-transition="none-out">
            <h3>HTML Example</h3>
            <pre><code class="html" data-noescape>&lt;html&gt;
  &lt;body&gt;
    page document body
    &lt;div&gt; div content &lt;/div&gt;
    &lt;span <mark>class="myclass1"</mark>&gt; span content &lt;/span&gt;
    &lt;div <mark>id="mydiv1"</mark>&gt; div content &lt;/div&gt;
    &lt;b <mark>style="text-color: red"</mark>&gt; bold red text &lt;/b&gt;
    &lt;div&gt;
      &lt;b&gt; bold text within a div &lt;/b&gt;
      &lt;span&gt; span content within a div &lt;/span&gt;
    &lt;/div&gt;
    &lt;a <mark>href="http://w3c.org"</mark>&gt; text of link to W3C &lt;/a&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
            <aside class="notes">
              <ul>
                <li>Second: HTML attributes.
                <li>Some attributes like class and id are global while
                  other like href are specific to certain types of
                  elements.
              </ul> 
            </aside>
          </section>
          <section>
            <h3>CSS 3</h3>
            <ul>
              <li>W3C Standard
              <li>50 sub-specifications (modules)
              <li>360 CSS properties
            </ul>
            <aside class="notes">
              <ul>
                <li>CSS is also a World Web Consortium standard.
                <li>CSS 3 is the major version of the standard.
                <li>The CSS standard is a fair bit more complicated
                  than the HTML one in terms of its grammar.
                <li>There are actually 50 different sub-specifications
                  referred to as CSS3 modules which are in various
                  stages of standardization.
                <li>There are more than 360 CSS property names across
                  all the CSS3 modules.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>CSS 3 Example</h3>
            <ul style="list-style: none">
              <li>Stylesheet:
            </ul>
            <pre><code class="css"  data-noescape>.classname #idname tagname {
  background: rgba(0, 0, 0, 0.5);
  border: 1px solid #fff;
  transform: translate3d(0px, 0px, -45px) rotateX(90deg);
}
            </code></pre>
            <aside class="notes">
              <ul>
                <li>Here is an example of a CSS stylesheet.
                <li>There are four main components
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>CSS 3 Example</h3>
            <ul style="list-style: none">
              <li>Stylesheet:
            </ul>
            <pre><code class="css"  data-noescape><mark>.classname #idname tagname</mark> {
  background: rgba(0, 0, 0, 0.5);
  border: 1px solid #fff;
  transform: translate3d(0px, 0px, -45px) rotateX(90deg);
}
            </code></pre>
            <aside class="notes">
              <ul>
                <li>1) Selectors, which identify which HTML elements the
                following block will apply to.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>CSS 3 Example</h3>
            <ul style="list-style: none">
              <li>Stylesheet:
            </ul>
            <pre><code class="css"  data-noescape>.classname #idname tagname {
  <mark>background: rgba(0, 0, 0, 0.5);</mark>
  <mark>border: 1px solid #fff;</mark>
  <mark>transform: translate3d(0px, 0px, -45px) rotateX(90deg);</mark>
}
            </code></pre>
            <aside class="notes">
              <ul>
                <li>A block of declarations.
                <li>Each declaration consists of ...
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>CSS 3 Example</h3>
            <ul style="list-style: none">
              <li>Stylesheet:
            </ul>
            <pre><code class="css"  data-noescape>.classname #idname tagname {
  <mark>background</mark>: rgba(0, 0, 0, 0.5);
  <mark>border</mark>: 1px solid #fff;
  <mark>transform</mark>: translate3d(0px, 0px, -45px) rotateX(90deg);
}
            </code></pre>
            <aside class="notes">
              <ul>
                <li>Property names and ...
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>CSS 3 Example</h3>
            <ul style="list-style: none">
              <li>Stylesheet:
            </ul>
            <pre><code class="css"  data-noescape>.classname #idname tagname {
  background: <mark>rgba(0, 0, 0, 0.5);</mark>
  border: <mark>1px solid #fff;</mark>
  transform: <mark>translate3d(0px, 0px, -45px) rotateX(90deg);</mark>
}
            </code></pre>
            <aside class="notes">
              <ul>
                <li>Value data
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>CSS 3 Example</h3>
            <ul>
              <li>Inline:
            </ul>
            <pre><code class="html"  data-noescape>&lt;div style="background: rgba(0, 0, 0, 0.5);
            border: 1px solid #fff;
            transform: translate3d(0px, 0px, -45px)
                       rotateX(90deg);"&gt;
  div content
&lt;/div&gt;
            </code></pre>
            <aside class="notes">
              <ul>
                <li>These are the same definitions from the previous
                  example but embedded inline into the HTML.
                <li>The selectors are omitted because these
                  declarations only apply to the HTML elements that
                  they embedded within.
              </ul>
            </aside>
          </section>
          <section>
            <h3>CSS Value Definition Syntax (VDS)</h3>
            <ul class="fragment">
              <li>VDS
            <pre><code class="css overflow"  data-noescape><'text-emphasis-position'> =
  [ over | under ] && [ right | left ]</code></pre>
              <li class="fragment">EBNF
            <pre><code class="bash overflow"  data-noescape>prop-text-emphasis-position =
  ( ( 'over' ' ' | 'under' ' ') ' '
    ( 'right' ' ' | 'left' ' ') ' ' ) ;</code></pre>
            <aside class="notes">
              <ul>
                <li>Bulk of the CSS3 standard is dedicated to defining
                  CSS values.
                <li>CSS values are defined using a bespoke grammar
                  called Value Definition Syntax (or VDS).
                <li>The grammar is similar to EBNF but with additional
                  combinators that are optimized to deal with the
                  ordering and repetition flexibility that CSS values
                  permits.
                <li><font color="green">[show fragment #1]</font>
                  Here is an example of the VDS definition of the
                  values for the <b>text-emphasis-position</b>
                  property name.
                <li>This definition states that the value should be
                  either the word "over" or "under" and either the
                  word "right" or "left".
                <li><font color="green">[show fragment #1]</font>
                  This is the equivalent EBNF translation of the VDS
                  grammar.
              </ul>
            </aside>
          </section>
          <section>
            <h3>CSS Value Definition Syntax (VDS)</h3>
            <ul>
              <li>EBNF
            <pre><code class="bash overflow"  data-noescape>prop-text-emphasis-position =
  ( ( 'over' ' ' | 'under' ' ') ' '
    ( 'right' ' ' | 'left' ' ') ' ' ) ;</code></pre>
              <li>Generators:
            <pre><code class="clojure overflow"  data-noescape>(gen/tuple
  (gen/frequency [
    [100 (gen/tuple (gen/return "over") (gen/return " "))]
    [100 (gen/tuple (gen/return "under") (gen/return " "))]])
  (gen/return " ")
  (gen/frequency [
    [100 (gen/tuple (gen/return "right") (gen/return " "))]
    [100 (gen/tuple (gen/return "left") (gen/return " "))]])
  (gen/return " "))
            </code></pre>
            </ul>
            <aside class="notes">
              <ul>
                <li>The EBNF is then translated into Clojure
                  test.check generator code.
                <li>The frequency generator selects between multiple
                  other generators based on weights. In this case the
                  even weights result in 50% chance of choosing the
                  over/under and right/left pairs.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Controlling the Grammar</h3>
            <ul>
              <li>Tunable weights at grammar branch points
              <li class="fragment">Enables:
                <ul>
                  <li>Single component testing
                  <li>Avoid known failures
                  <li>Pairwise or combinatorial testing
                  <li>Typical and atypical test cases
                </ul>
            </ul>
            <aside class="notes">
              <ul>
                <li>One of our goals of our overall approach is that
                  the system is controllable.
                <li>We accomplish this by having tunable weights
                  associated with each branch point in the grammar.
                <li><font color="green">[show fragment #1]</font>
                  Grammar controlability enables a number of
                  interesting scenarios such as:
                  <ul>
                    <li><b>Single component testing</b>. For example
                      there may be a new HTML element that we want to
                      focus our testing on.
                    <li><b>Avoid known failures</b>. For example, we
                      may have found a bug hyperlink rendering that
                      occurs frequently. We can continue testing
                      without requiring a fix to the SUT by disabling
                      the part of the grammar that generates
                      hyperlinks.
                    <li><b>Pairwise or combinatorial testing</b>. Many
                      bugs are triggered by the interaction a small
                      number of components that make up the SUT. So
                      pairwise and combinatorial testing can be an
                      efficient way to locate bugs in the SUT.
                    <li><b>Typical and atypical test cases</b>.
                      Sometimes we are interested in testing our SUT
                      on typical data. For example we may want to gain
                      confidence that our browser will render the top
                      100 web sites correctly. Other times we may want
                      to focus on uncommon elements. Perhaps we just
                      introduced some new elements to the SUT that are
                      not widely used yet.
                  </ul>
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Revisiting the Grammar</h3>
            <ul style="list-style: none">
              <li><font color="yellow">text-emphasis-position</font> generator:
            <pre><code class="clojure overflow"  data-noescape>(gen/tuple
  (gen/frequency [
    [100                                                          &nbsp;
      (gen/tuple (gen/return "over") (gen/return " "))]
    [100
      (gen/tuple (gen/return "under") (gen/return " "))]])
  (gen/return " ")
  (gen/frequency [
    [100
      (gen/tuple (gen/return "right" (gen/return " ")))]
    [100
      (gen/tuple (gen/return "left") (gen/return " "))]])
  (gen/return " "))
            </code></pre>
            </ul>
            <aside class="notes">
              <ul>
                <li>Here is the grammar I showed earlier.
                <li>This is actually omitting the extra parts that
                  allow the grammar to be controlled or tuned.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Revisiting the Grammar</h3>
            <ul style="list-style: none">
              <li><font color="yellow">text-emphasis-position</font> generator:
            <pre><code class="clojure overflow"  data-noescape>(gen/tuple
  (gen/frequency [
    [(get weights [:prop-text-emphasis-position :cat 1 :alt 0] 100)
      (gen/tuple (gen/return "over") (gen/return " "))]
    [(get weights [:prop-text-emphasis-position :cat 1 :alt 1] 100)
      (gen/tuple (gen/return "under") (gen/return " "))]])
  (gen/return " ")
  (gen/frequency [
    [(get weights [:prop-text-emphasis-position :cat 3 :alt 0] 100)
      (gen/tuple (gen/return "right") (gen/return " "))]
    [(get weights [:prop-text-emphasis-position :cat 3 :alt 1] 100)
      (gen/tuple (gen/return "left") (gen/return " "))]])
  (gen/return " "))
            </code></pre>
            </ul>
            <aside class="notes">
              <ul>
                <li>Here is what the full emitted grammar looks like
                  with the weight lookups included.
                <li>The weights variable in the example is a lookup
                  table built from the default weights overlayed with
                  value loaded from a tester's weight file.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Weights File</h3>
            <ul style="list-style: none">
              <li>weights.edn:
            <pre><code class="clojure overflow"  data-noescape>{
...
 [:prop-text-emphasis-position :cat 1 :alt 0] 100,
 [:prop-text-emphasis-position :cat 1 :alt 1]  50,
 [:prop-text-emphasis-position :cat 3 :alt 0] 100,
 [:prop-text-emphasis-position :cat 3 :alt 1]  50,
...
}</code></pre>
            <aside class="notes">
              <ul>
                <li>Corresponding data from the weight file.
                <li>This example makes the "over" and "right" words
                  twice as common as under and left.
              </ul>
            </aside>
          </section>
        </section>
        <section data-transition="none">
          <section>
            <h2>Consensus</h2>
            <ul>
              <li class="fragment">Goals
                <ul>
                  <li>Automated
                  <li>Controllable
                </ul>
            </ul>
            <aside class="notes">
              <ul>
                <li>We have a way to generate web page test cases
                  that are <b>automated</b> and <b>controllable</b>,
                  but how do determine whether our browser correctly
                  renders these test cases.
                <li>It turns out that our goals for determining
                  correctness are the same as for generating the inputs
                  <li> <font color="green">[show fragment #1]</font>
                    Goals:
                  <ul>
                    <li><b>Automated</b>: a human shouldn't have to
                      determine whether a browser has rendered a web
                      page correctly. Which has means we also need to
                      minimize false positives and false negatives.
                    <li><b>Controllable</b>: To explain why this is
                      important I'll have to descirbe how a consensus
                      Oracle works. <!-- TODO -->
                  <ul>
                    <li>
                    <li>
                  </ul>
              </ul> 
            </aside>
          </section>
          <section>
            <h2>Consensus Oracle</h2>
            <ul>
              <li class="fragment">Multiple implementations
              <li class="fragment">Chrome, Firefox, Safari, Edge,
                Opera, Vivaldi, Brave, UC Browser, Internet Explorer,
                Chromium, Servo, Pale Moon, Dolphin, Tor Browser,
                Maxthon, Baidu Browser, etc, etc
            </ul>
            <aside class="notes">
              <ul>
                <li><font color="green">[show fragment #1]</font> The
                  key insight here is that a number of cases in the
                  real-world where SUTs will have multiple
                  implementations.
                <li>This is particularly true in the web browser space
                  where there is a surplus of implementations.<font
                    color="green">[show fragment #1]</font>
              </ul> 
            </aside>
          </section>
          <section>
            <h2>Consensus Example</h2>
            <pre><code class="html"  data-noescape>&lt;html&gt;
  &lt;body style="background: #1289af; font: 25px/1 Ahem"&gt;
    &lt;marquee bgcolor="navy"&gt;
      &lt;q <font color="yellow">...ELIDED...</font> &gt; pX &lt;/q&gt;
    &lt;/marquee&gt;
    p
    &lt;mark <font color="yellow">...ELIDED...</font>&gt; &lt;/mark&gt;
    &lt;strong style="offset-anchor: right;
                   box-align: stretch;
                   padding-right: -1.75vw" <font color="yellow">...ELIDED...</font>&gt;
      &lt;mark <font color="yellow">...ELIDED...</font>&gt; Xp XX &lt;/mark&gt;
      &amp;#x00c9;
    &lt;/strong&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
            <aside class="notes">
              <ul>
                <li>Here is a example web page that was generated
                  using HTML and CSS generators.
              </ul>
            </aside>
          </section>
          <section>
            <h2>Consensus Example</h2>
            <table class="browser-table">
              <tr>
                <td style="padding: 0px; text-align: center; vertical-align: top">
                  <div style="visibility: hidden">FFFFFFF</div>
                  <span>Firefox&nbsp;&nbsp;</span>
                  <img src="imgs/results1_7_firefox.png"
                       style="margin: 5px"></img>
                </td>
                <td style="padding: 0px; text-align: center; vertical-align: top">
                  <div style="visibility: hidden">FFFFFFF</div>
                  <span>Chrome</span>
                  <img src="imgs/results1_7_chrome.png"
                       style="margin: 5px"></img>
                </td>
                <td style="padding: 0px; text-align: center; vertical-align: top">
                  <div style="visibility: hidden">FFFFFFF</div>
                  <span>Servo&nbsp;&nbsp;&nbsp;&nbsp;</span>
                  <img src="imgs/results1_7_servo.png"
                       style="margin: 5px"></img>
                </td>
              </tr>
            </table>
            <aside class="notes">
              <ul>
                <li>And here are the results of rendering that page in
                  three popular browsers.
                <li>It is pretty clear just from visual inspection
                  that Servo has significantly different rendering
                  from the other two however, it's not as obvious
                  whether Firefox and Chrome are different.
              </ul>
            </aside>
          </section>
          <section>
            <table class="browser-table">
              <tr>
                <td style="padding: 0px; text-align: center; vertical-align: top">
                  <span>Firefox</span>
                  <img src="imgs/results1_7_firefox.png"
                       style="margin: 5px"></img>
                </td>
                <td style="padding: 0px; text-align: center; vertical-align: top"
                    class="fragment" data-fragment-index=1>
                  <img src="imgs/results1_7_diff_firefox_servo.png"
                       style="margin: 5px"></img>
                  <div style="visibility: hidden">FFFFFFF</div>
                </td>
                <td style="padding: 0px; text-align: center; vertical-align: top">
                  <span>Servo</span>
                  <img src="imgs/results1_7_servo.png"
                       style="margin: 5px"></img>
                </td>
              </tr>
              <tr>
                <td style="padding: 0px; text-align: center; vertical-align: top"
                    class="fragment" data-fragment-index=1>
                  <img src="imgs/results1_7_diff_firefox_chrome.png"
                       style="margin: 5px"></img>
                  <div style="visibility: hidden">FFFFFFF</div>
                </td>
                <td style="padding: 0px; text-align: center; vertical-align: top">
                  <span>Chrome</span>
                  <img src="imgs/results1_7_chrome.png"
                       style="margin: 5px"></img>
                </td>
                <td style="padding: 0px; text-align: center; vertical-align: top"
                    class="fragment" data-fragment-index=1>
                  <img src="imgs/results1_7_diff_chrome_servo.png"
                       style="margin: 5px"></img>
                  <div style="visibility: hidden">FFFFFFF</div>
                </td>
              </tr>
            </table>
            <aside class="notes">
              <ul>
                <li>Let's re-arrange them
                <li>And now let's show the result of subtracting the
                  color channel values for each pair of browsers.
                  <font color="green">[show fragment #1]</font>
                  Black areas in the difference images mean that color
                  at that pixel in both images was identical.
                <li>Now it's easy to see the difference between Servo
                  and the other two browsers.
                <li>We can also see that Firefox and Chrome are very
                  similar although there are in fact some subtle
                  spacing differences between the HTML elements.
                <li>This raises the question of how do we determine if
                  there is in fact consensus or not?
              </ul>
            </aside>
          </section>
          <section>
            Simple Squared Sum of Differences (SSD) with a threshold.
          </section>
          <section>
            <img src="imgs/results1.png" width=80%></img>
          </section>
          <section>
            <img src="imgs/results1_expanded.png" width=80%></img>
          </section>
        </section>
        <section>
          <h2>Results</h2>
            <aside class="notes">
              <ul>
                <li>
                <li><font color="green">[show fragment #1]</font>
                  <ul>
                    <li>
                  </ul>
              </ul> 
            </aside>
        </section>
        <section>
          <h3>Questions?</h3>
        </section>
        <section>
          <h3>Contact</h3>
          <ul style="list-style: none">
            <li><a href="//twitter.com/bus_kanaka">@bus_kanaka</a>
            <li><a href="//kanaka.github.io/compsac2018">kanaka.github.io/compsac2018</a>
            <li><a href="//github.com/kanaka">github.com/kanaka</a>
            <li>joeldmartin@mavs.uta.edu
            <li>levine@cse.uta.edu
          </ul>
        </section>
          <aside class="notes">
            <ul>
              <li>
                <li><font color="green">[show fragment #1]</font>
                  <ul>
                    <li>
                  </ul>
            </ul> 
          </aside>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>

<!-- vim: ts=2:sw=2:set expandtab -->
